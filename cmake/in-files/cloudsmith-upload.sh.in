#!/usr/bin/env bash

#
# Upload the .tar.gz and .xml artifacts to cloudsmith 
#
# Builds are uploaded to one of PROD, BETA or ALPHA repositories
# The repository depends on the branch and use of tag to determine which repo.
# ALPHA: Non-master branch no tag
# BETA: Non-master branch with annotated tag
# BETA: Master branch no tag
# PROD: Master branch with annotated tag
#
# If this script is used on CIRCLECI, TRAVIS or APPVEYOR it will upload the correct files to the chosen repository
# If this script is used locally it will build the correct artifacts but will not do the upload
#

set -xe

PROD_REPO=${CLOUDSMITH_PROD_REPO:-'@CLOUDSMITH_USER@/@CLOUDSMITH_BASE_REPOSITORY@-@PROD@'}
BETA_REPO=${CLOUDSMITH_BETA_REPO:-'@CLOUDSMITH_USER@/@CLOUDSMITH_BASE_REPOSITORY@-@BETA@'}
ALPHA_REPO=${CLOUDSMITH_ALPHA_REPO:-'@CLOUDSMITH_USER@/@CLOUDSMITH_BASE_REPOSITORY@-@ALPHA@'}

LOCAL_BUILD=false

if [ "$CIRCLECI" ]; then
    BUILD_ID=${CIRCLE_BUILD_NUM:-1}
    BUILD_DIR=$HOME/project/build
    BUILD_BRANCH=$CIRCLE_BRANCH
    BUILD_TAG=$CIRCLE_TAG
    PKG_EXT=${CLOUDSMITH_PKG_EXT:-'deb'}
elif [ "$TRAVIS" ]; then
    BUILD_ID=${TRAVIS_BUILD_NUM:-1}
    BUILD_DIR=$TRAVIS_BUILD_DIR/build
    BUILD_BRANCH=$TRAVIS_BRANCH
    BUILD_TAG=$TRAVIS_TAG
    if [ "$BUILD_BRANCH" = "$BUILD_TAG" ]; then
        BUILD_BRANCH=""
    fi
    PKG_EXT=${CLOUDSMITH_PKG_EXT:-'deb'}
elif [ "$APPVEYOR" ]; then
    BUILD_ID=${APPVEYOR_BUILD_NUMBER:-1}
    BUILD_DIR=$(pwd)
    BUILD_BRANCH=$APPVEYOR_REPO_BRANCH
    BUILD_TAG=$APPVEYOR_REPO_TAG_NAME
    PKG_EXT=${CLOUDSMITH_PKG_EXT:-'exe'}
elif [ "$GITHUB_ACTIONS" = "true" ]; then
    BUILD_ID=${GITHUB_RUN_NUMBER:-1}
    BUILD_DIR=$GITHUB_WORKSPACE/build

    # Branch/Tag aus GITHUB_REF ableiten
    case "$GITHUB_REF" in
        refs/heads/*)
            BUILD_BRANCH=${GITHUB_REF#refs/heads/}
            BUILD_TAG=""
            ;;
        refs/tags/*)
            BUILD_BRANCH=""
            BUILD_TAG=${GITHUB_REF#refs/tags/}
            ;;
        *)
            BUILD_BRANCH=""
            BUILD_TAG=""
            ;;
    esac

    # Für Flatpak: nur .tar.gz relevant, kein deb/exe
    PKG_EXT=${CLOUDSMITH_PKG_EXT:-'gz'}
else
    BUILD_ID=${CIRCLE_BUILD_NUM:-1}
    BUILD_DIR=.
    BUILD_BRANCH=$CIRCLE_BRANCH
    BUILD_TAG=$CIRCLE_TAG
    PKG_EXT=${CLOUDSMITH_PKG_EXT:-'deb'}
    LOCAL_BUILD=true
fi

set +x
if [ -z "$CLOUDSMITH_API_KEY" ] && [ "$LOCAL_BUILD" = "false" ]; then
    echo 'Cannot deploy to cloudsmith, missing $CLOUDSMITH_API_KEY'
    exit 0
fi
set -x

if [ "$CIRCLECI" ] || [ "$TRAVIS" ]; then
    if [ "$DEPLOY_USE_ORB" != "true" ]; then
        if pyenv versions 2>&1 >/dev/null; then
          pyenv versions
          version_1=$(python --version | cut -d '.' -f1 | cut -d ' ' -f2)
          version_2=$(python --version | cut -d '.' -f2)
          if [ $version_1 -lt 3 ] || [ $version_2 -lt 5 ]; then
            sudo apt install software-properties-common
            sudo apt update
            sudo apt install -y python3.8 python3-pip
            sudo rm /usr/bin/python3
            sudo ln -s /usr/bin/python3.8 /usr/bin/python3
          fi
          python3 --version
          sudo python3 -m pip install cloudsmith-cli
          pyenv rehash
        elif test -d $HOME/cs-venv; then
            source $HOME/cs-venv/bin/activate
            python -m pip install cloudsmith-cli
        elif dnf --version 2>&1 >/dev/null; then
            sudo dnf -y install python3-pip python3-setuptools
            sudo python3 -m pip install -q cloudsmith-cli
        elif apt-get --version 2>&1 >/dev/null; then
            COUNTER=0
            sudo apt install software-properties-common
            sudo apt update
            sudo apt install -y python3.8
            sudo rm /usr/bin/python3
            sudo ln -s /usr/bin/python3.8 /usr/bin/python3
            until
                sudo apt-get install python3-pip python3-setuptools
            do
                if [ "$COUNTER" -gt  "20" ]; then
                    exit -1
                fi
                sleep 5
                ((COUNTER++))
            done
            sudo python3 -m pip install --upgrade pip
            sudo python3 -m pip install -q cloudsmith-cli
        fi
    fi
fi

commit=$(git rev-parse --short=7 HEAD) || commit="unknown"
tag=$(git tag --contains HEAD)

ls -la
pwd
xml=$(ls $BUILD_DIR/*.xml)
cat $xml
tarball=$(ls $BUILD_DIR/*.tar.gz)
tarball_basename=${tarball##*/}
echo $tarball
echo $tarball_basename

source $BUILD_DIR/pkg_version.sh
if [ -n "${OCPN_TARGET}" ]; then
    tarball_name=@PACKAGE_NAME@-@PACKAGE_VERSION@-${PKG_TARGET}-@COMPOUND_ARCH_DASH@@PKG_TARGET_WX_VER@@PKG_BUILD_GTK@-${PKG_TARGET_VERSION}-${OCPN_TARGET}-tarball
else
    tarball_name=@PACKAGE_NAME@-@PACKAGE_VERSION@-${PKG_TARGET}-@COMPOUND_ARCH_DASH@@PKG_TARGET_WX_VER@@PKG_BUILD_GTK@-${PKG_TARGET_VERSION}-tarball
fi

if [ "$(ls $BUILD_DIR/*.${PKG_EXT})" ]; then
    pkg=$(ls $BUILD_DIR/*.${PKG_EXT})
else
    pkg=""
fi

echo $BUILD_BRANCH
echo $BUILD_TAG
echo ${#BUILD_TAG}
# Normalize branch name
BUILD_BRANCH_LOWER=$(echo "$BUILD_BRANCH" | tr 'A-Z' 'a-z')

echo "Branch: $BUILD_BRANCH_LOWER"
echo "Tag: $BUILD_TAG"

#
# 1) TAGGED BUILDS
#
if [ -n "$BUILD_TAG" ]; then
    VERSION="$BUILD_TAG"

    # Beta-Tags enthalten das Wort "beta"
    if [[ "$BUILD_TAG" == *beta* ]]; then
        echo "Detected beta tag → uploading to BETA repo"
        REPO="$BETA_REPO"
    else
        echo "Detected production tag → uploading to PROD repo"
        REPO="$PROD_REPO"
    fi

#
# 2) UNTAGGED BUILDS → ALPHA
#
else
    echo "No tag detected → uploading to ALPHA repo"
    VERSION="@PROJECT_VERSION@+${BUILD_ID}.${commit}"
    REPO="$ALPHA_REPO"
fi

echo "VERSION=$VERSION"
echo "REPO=$REPO"

if [ "$APPVEYOR" ] || [ "$LOCAL_BUILD" = "true" ]; then
    echo 'substituting xml file variables for windows build'
    while read line; do
        line=${line//--pkg_repo--/$REPO}
        line=${line//--name--/$tarball_name}
        line=${line//--version--/$VERSION}
        line=${line//--filename--/$tarball_basename}
        echo $line
    done < "$xml" > xml.tmp && cat xml.tmp && cp xml.tmp $xml && rm xml.tmp
else
    echo 'substituting xml file variables for non-windows build'
    sudo sed -i -e "s|--pkg_repo--|$REPO|"  $xml
    sudo sed -i -e "s|--name--|$tarball_name|" $xml
    sudo sed -i -e "s|--version--|$VERSION|" $xml
    sudo sed -i -e "s|--filename--|$tarball_basename|" $xml
fi

cat $xml
ls -l $BUILD_DIR
cur_dir=$(pwd)
gunzip -f $tarball
cd "$BUILD_DIR"
rm -f metadata.xml
tarball_tar=$(ls *.tar)
xml_here=$(ls *.xml)
cp -f $xml_here metadata.xml
if [ "$TRAVIS" ] || [ "$CIRCLECI" ] || [ ! -z ${LOCAL_DEPLOY+x} ]; then
    mkdir build_tar
    cp $tarball_tar build_tar/.
    cd build_tar
    tar -xf $tarball_tar
    rm *.tar
    rm -rf root
    cp ../metadata.xml .
    tar -cf build_tarfile.tar *
    tar -tf build_tarfile.tar
    rm ../$tarball_tar
    cp build_tarfile.tar ../$tarball_tar
    cd ..
    rm -rf build_tar
else
    tar -rf $tarball_tar metadata.xml
fi
tar -tf $tarball_tar
gzip -f $tarball_tar
pwd
cd "$cur_dir"
pwd
ls -la
ls -la ~/.

# Find if file exists in directory
function have_any() {
    [ $# -gt 0 ]
}

if [ ! -z ${LOCAL_DEPLOY+x} ]; then
    if [ -d "/home/circleci/circleci-output" ]; then
        sudo cp build/*.gz ~/circleci-output
        if have_any ./build/*.deb; then
            sudo cp ./build/*.deb ~/circleci-output
        elif have_any ./build/*.exe; then
            sudo cp ./build/*.exe ~/circleci-output
        fi
    else
        echo "Directory ~/circleci-output not found"
    fi
elif [ $LOCAL_BUILD = false ]; then
#    Following statement does not work, if circleci is triggered by Github action:
#    if [ "$CIRCLE_PROJECT_USERNAME" = "$CIRCLE_USERNAME" ] || [[ -n "${collab_users+1}"  && ! -z ${CIRCLE_USERNAME}  && "$collab_users" =~ "$git_user" ]]; then

     # Funktion: vorhandenes Paket löschen
     delete_if_exists() {
         local name="$1"
         echo "Searching for existing packages with name: $name"
         
         # Hole alle Packages mit diesem Namen über die API
         local packages=$(curl -s \
        -H "X-Api-Key: ${CLOUDSMITH_API_KEY}" \
        -H "Accept: application/json" \
        "https://api.cloudsmith.io/v1/packages/${REPO}/?query=name:${name}" \
        | jq -r '.[] | select(.name == "'"$name"'") | .slug_perm')
    
         if [ -z "$packages" ]; then
             echo "No existing packages found with name: $name"
             return 0
         fi
         
         # Lösche jedes gefundene Package
         echo "$packages" | while read -r slug; do
             if [ -n "$slug" ]; then
                 echo "Deleting package with slug: $slug"
                 cloudsmith delete "${REPO}/${slug}" --yes 2>/dev/null || echo "Failed to delete $slug (may already be gone)"
             fi
         done
         
         echo "Cleanup complete for: $name"
     }

     #
     # 1) METADATA XML
     #
     xml_name="@PACKAGE_NAME@-@PACKAGE_VERSION@-@PKG_TARGET@-@COMPOUND_ARCH_DASH@@PKG_TARGET_WX_VER@@PKG_BUILD_GTK@-@PKG_TARGET_VERSION@-${OCPN_TARGET}-metadata"
     if [ -f "$xml" ]; then
         echo "Checking Cloudsmith for existing metadata package: $xml_name"
         delete_if_exists "$xml_name"
         cloudsmith push raw --republish --no-wait-for-sync \
             --name "$xml_name" \
             --version "${VERSION}" \
             --summary "@PACKAGE@ opencpn plugin metadata for automatic installation" \
             "$REPO" "$xml"
     fi
     #
     # 2) TARBALL
     #
     tar_name="$tarball_name"
     if [ -f "$tarball" ]; then
         echo "Checking Cloudsmith for existing tarball: $tar_name"
         delete_if_exists "$tar_name"
         cloudsmith push raw --republish --no-wait-for-sync \
             --name "$tar_name" \
             --version "${VERSION}" \
             --summary "@PACKAGE@ opencpn plugin tarball for automatic installation" \
             "$REPO" "$tarball"
     fi
     #
     # 3) INSTALLATION PACKAGE (.deb, .apk, .zip, etc.)
     #
     pkg_name="opencpn-package-@PACKAGE@-@PACKAGE_VERSION@-@PKG_TARGET@-@COMPOUND_ARCH_DASH@@PKG_TARGET_WX_VER@@PKG_BUILD_GTK@-@PKG_TARGET_VERSION@-${OCPN_TARGET}.${PKG_EXT}"
     if [ "${PKG_EXT}" != "gz" ] && [ -f "$pkg" ]; then
         echo "Checking Cloudsmith for existing install package: $pkg_name"
         delete_if_exists "$pkg_name"
         cloudsmith push raw --republish --no-wait-for-sync \
             --name "$pkg_name" \
             --version "${VERSION}" \
             --summary "@PACKAGE@ .${PKG_EXT} installation package" \
             "$REPO" "$pkg"
     fi
fi
